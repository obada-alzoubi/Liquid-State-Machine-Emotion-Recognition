function visualize(varargin)
%VISUALIZE   visualizes pool circuit template states.
%   VISUALIZE(P,ST) visualizes the circuit states ST of pool
%   circuit templates. The circuit state ST variable is an NC-by-NS 
%   cell array, where NC is the number of pool circuit templates 
%   and NS is the number of input stimuli as generated by 
%   ST = RESPONSE2STATES(P,R,M).
%
%   For each circuit a figure with the states of the responses 
%   of the circuit to all input stimuli S is plotted.
%
%   VISUALIZE(P,R,'surface','off') plots only the states of the
%   and no interconnecting surface between the states.
%
%   VISUALIZE(P,R,'group','circuit') performs the same visualization
%   as described above but plots for each input stimulus a figure with
%   the states of the responses of all pool circuit templates.
%
%   VISUALIZE(P,R,'pdf',FILENAME) creates a pdf file FILENAME that
%   contains all matlab figures.
%
%   VISUALIZE(P,R,'show pdf',FILENAME) additional opens the created
%   pdf file FILENAME with the acrobat reader.
%
%
%   See also POOL_CIRCUIT_TEMPLATE/GENERATE
%            POOL_CIRCUIT_TEMPLATE/PLOT
%	     POOL_CIRCUIT_TEMPLATE/POOL_CIRCUIT_TEMPLATE
%            POOL_CIRCUIT_TEMPLATE/ADJUST
%	     POOL_CIRCUIT_TEMPLATE/MODEL2STATES
%            POOL_CIRCUIT_TEMPLATE/STATES2MODEL
%	     POOL_CIRCUIT_TEMPLATE/SIMULATE
%
%   Author: Stefan Haeusler, 5/2003, haeusler@igi.tu-graz.ac.at

ALL = -1;
LAST = -2;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% identify input arguments
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

this = varargin{1};
smc_class_name = class(this); % first argument must be from the POOL_CIRCUIT_TEMPLATE class

for i = 1:nargin
   class_names{i} = class(varargin{i});
end


% identify structures
%-----------------------

idx = strmatch('struct',class_names,'exact');
if ~isempty(idx)
   errstr = error(' Function ''visualize'' not defined for arguments of class ''struct''.');
end

% identify state cell array
%-----------------------------


idx = strmatch('cell',class_names,'exact');
if length(idx) > 1
   errstr = error(' Function ''visualize'' not defined for multiple state arguments.');
end

if isempty(idx)
   error('Not enough input arguments. State variable not found.')
end

ST = varargin{idx};

try
   str = fieldnames(ST{1,1});
catch
   errstr = sprintf(' Function ''visualize'' only defined for cell arrays of ''struct'' elements.');
   error(errstr);
end

if ~strcmp([str{:}],'datainfo')
   errstr = sprintf('\n  ''%s''',str{:});
   errstr = sprintf(' Function ''visualize'' not defined for cell arrays of ''struct'' elements with fields:%s',errstr);
   error(errstr);
end


% identify command strings
%-------------------------

% default values

GROUP = 0;
SHOW_PDF = 0;
filename = [];
PLOT_SURFACE = 0;
ABSOLUTE_OUTPUT = 1;

str = [];
idx = strmatch('char',class_names,'exact');
j = 1;
while j <= length(idx)
      i = idx(j);

      % check if second argument is present
      if (i+1)>nargin
        errstr = sprintf('Not enough input arguments for command ''%s''.',varargin{i});
        error(errstr);
      end

      switch varargin{i}
         case 'pdf'
            % check if second argument is of the class 'char'
            if isempty(strmatch('char',class(varargin{i+1}),'exact'))
               errstr = sprintf(' Command ''%s'' not defined for arguments of class ''%s''.',varargin{i},class(varargin{i+1}));
               error(errstr);
            end

            j = j + 1; % skip argument string in varargin
            filename = varargin{i+1};
         case 'show pdf'
            % check if second argument is of the class 'char'
            if isempty(strmatch('char',class(varargin{i+1}),'exact'))
               errstr = sprintf(' Command ''%s'' not defined for arguments of class ''%s''.',varargin{i},class(varargin{i+1}));
               error(errstr);
            end

            j = j + 1; % skip argument string in varargin
            filename = varargin{i+1};
            SHOW_PDF = 1;
         case 'group'
            % check if second argument is of the class 'char'
            if isempty(strmatch('char',class(varargin{i+1}),'exact'))
               errstr = sprintf(' Command ''%s'' not defined for arguments of class ''%s''.',varargin{i},class(varargin{i+1}));
               error(errstr);
            end

            j = j + 1; % skip argument string in varargin

            if ~isempty(strmatch(varargin{i+1},'circuit','exact'));
               GROUP = 1;
            elseif ~isempty(strmatch(varargin{i+1},'input','exact'));
               GROUP = 0;
            else
               errstr = sprintf(' Command ''%s'' not defined for argument ''%s''.',varargin{i},varargin{i+1});
               error(errstr)
            end
            SHOW_PDF = 1;
	 case 'absolute output'
            % check if second argument is of the class 'char'
            if isempty(strmatch('char',class(varargin{i+1}),'exact'))
               errstr = sprintf(' Command ''%s'' not defined for arguments of class ''%s''.',varargin{i},class(varargin{i+1}));
               error(errstr);
            end

            j = j + 1; % skip argument string in varargin

            if strcmp(varargin{i+1},'on');
               ABSOLUTE_OUTPUT = 1;
            elseif strcmp(varargin{i+1},'off');
               ABSOLUTE_OUTPUT = 0;
            else
               errstr = sprintf(' Command ''%s'' not defined for argument ''%s''.',varargin{i},varargin{i+1});
               error(errstr)
            end
         case 'surface'
            % check if second argument is of the class 'char'
            if isempty(strmatch('char',class(varargin{i+1}),'exact'))
               errstr = sprintf(' Command ''%s'' not defined for arguments of class ''%s''.',varargin{i},class(varargin{i+1}));
               error(errstr);
            end

            j = j + 1; % skip argument string in varargin

            if strcmp(varargin{i+1},'on');
               PLOT_SURFACE = 1;
            elseif strcmp(varargin{i+1},'off');
               PLOT_SURFACE = 0;
            else
               errstr = sprintf(' Command ''%s'' not defined for argument ''%s''.',varargin{i},varargin{i+1});
               error(errstr)
            end
         otherwise
            errstr = sprintf('Invalid command ''%s''.',varargin{i});
            error(errstr)
      end
   j = j + 1;
end

if filename & ~isempty(which('temp.ps'))
   delete temp.ps
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% MAIN part
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% determine Tmax
%---------------

nCircuits = size(ST,2);
nStimuli = size(ST,1);

colorcode = {'k-','b--','g:','r_.','co','mx','y+'};
colorname = {'Pool 1','Pool 2','Pool 3','Pool 4','Pool 5','Pool 6','Pool 7',};

Tmax = 0;
for nS = 1:nStimuli
   Tmax = max(Tmax,ST{1,1}.info.stimulus.S.info.Tstim);
end

if ~Tmax
   error('Time length of stimuli is zero.')
end


% plot
%-----


if GROUP == 0
   % one circuit & all stimuli per plot

   nFig = gcf;

   for nC = 1:nCircuits
      figure(nFig)
      clf
%      title(sprintf('Output for circuit %i',nC))
      title(sprintf('Output for %s',get(ST{nS,nC}.info.circuit.template,'name')))
      hold on

      % fill to at least 3 traces so surfl has no problems

      nOut = size(ST{nS,nC}.data,1);

      ko = [1:nOut];
      k = ko;
      while (length(k) < 3), k(end+1) = k(end); end

      YTick = [];      YTickLabel = [];
      YNameTick = [];  YNameTickLabel = [];

      xOfs = 0;

      for nS = 1:nStimuli

         y = xOfs + k;

         xOfs = y(end)+3; % set neuron number

         dt_out = Tmax/size(ST{nS,nC}.data,2); % set neuron number
         [X,Y] = meshgrid(dt_out:dt_out:Tmax,y,1);

         % save data for name label
         YNameTick(end+1) = mean(y(1:length(ko)));
         YNameTickLabel{end+1} = sprintf('''%s''',ST{nS,nC}.info.stimulus.S.info.name);

	 % plot surface

         if (length(ko) > 1) & PLOT_SURFACE
            h=surfl(X,Y,ST{nS,nC}.data(k,:),[90 10],'light');
            colormap([1 0 0;1 0 0]*1)
            set(h(1),'FaceAlpha',[0.5])
            material dull
            shading flat
         end

         % plot psc and spikes

         for j = 1:length(ko)
            % set neuron number
            YTick(end+1) =  y(j);
            YTickLabel{end+1} =  sprintf('%i',j);
%            YTickLabel{end+1} =  sprintf('%i',ko(j));

            % line of psc
            h_trace(j)=plot3(X(j,:),Y(j,:),ST{nS,nC}.data(j,:),colorcode{j});
         end
      end

      legend(h_trace,colorname(1:length(h_trace)))

      % set axis
      view([50 80])
      v = axis;
      v(1:4) = [0 Tmax 0 xOfs-2];
      axis(v)

      caxis('auto')
      if PLOT_SURFACE==0
         view([0 0])   % previously view([50 80]) must be executed, because otherwise v(5) = []
      end

      grid on
      xlabel('t [sec]')
      ylabel('Output channel')
      zlabel(ST{nS,nC}.info.method.label)

      set(gca,'YTick',YTick)
      set(gca,'YTickLabel',YTickLabel)
      
      % write name labels
      for i = 1: length(YNameTick)
        text(v(2) *1.15,YNameTick(i),v(5),YNameTickLabel{i},'Color',[1 0 0])
      end

      nFig = nFig + 1;
      drawnow

      if filename
         print -dpsc2 -append temp.ps
      end
   end
else
   % one stimulus & all circuits per plot

   nFig = gcf;

   for nS = 1:nStimuli
      figure(nFig)
      clf
      title(sprintf('Output for ''%s''',ST{nS,1}.info.stimulus.S.info.name),'Color',[1 0 0])
      hold on

      YTick = [];       YTickLabel = [];
      YNameTick = [];   YNameTickLabel = [];

      xOfs = 0;
      
      clear h_trace
      for nC = 1:nCircuits

         % fill to at least 3 traces so surfl has no problems

         nOut = size(ST{nS,nC}.data,1);

         ko = [1:nOut];
         k = ko;
         while (length(k) < 3), k(end+1) = k(end); end

         y = xOfs + k;

         xOfs = y(end)+3; % set neuron number

         dt_out = Tmax/size(ST{nS,nC}.data,2);% set neuron number% set neuron number% set neu% set neu% set neu% set neu% set neu% set neu% set neu% set neuron numberron numberron numberron numberron numberron numberron numberron number
         [X,Y] = meshgrid(dt_out:dt_out:Tmax,y,1);

         % save data for name label
         YNameTick(end+1) = mean(y(1:length(ko)));
%         YNameTickLabel{end+1} = sprintf('Circuit %i',nC);
         YNameTickLabel{end+1} = sprintf('%s',get(ST{nS,nC}.info.circuit.template,'name'));

	 % plot surface

         if (length(ko) > 1) & PLOT_SURFACE
            h=surfl(X,Y,ST{nS,nC}.data(k,:),[90 10],'light');
            colormap([1 0 0;1 0 0]*1)
            set(h(1),'FaceAlpha',[0.5])
            material dull
            shading flat
         end

         % plot psc and spikes

         for j = 1:length(ko)
            % set neuron number
            YTick(end+1) =  y(j);
            YTickLabel{end+1} =  sprintf('%i',j);
%            YTickLabel{end+1} =  sprintf('%i',ko(j));

            % line of psc
            h_trace(j)=plot3(X(j,:),Y(j,:),ST{nS,nC}.data(j,:),colorcode{j});

         end
      end

      legend(h_trace,colorname(1:length(h_trace)))

      % set axis
      view([50 80])
      v = axis;
      v(1:4) = [0 Tmax 0 xOfs-2];
      axis(v)

      caxis('auto')
      if PLOT_SURFACE==0
         view([0 0])
      end
      grid on
      xlabel('t [sec]')
      ylabel('Output channel')
      zlabel(ST{nS,nC}.info.method.label)

      set(gca,'YTick',YTick)
      set(gca,'YTickLabel',YTickLabel)

      % write name labels
      for i = 1: length(YNameTick)
        text(v(2) *1.15,YNameTick(i),v(5),YNameTickLabel{i})
      end

      nFig = nFig + 1;
      drawnow

      if filename
         print -dpsc2 -append temp.ps
      end

   end

end


% pdf options
%------------

if filename
   eval(sprintf('!ps2pdf temp.ps %s',filename))

   if SHOW_PDF
      fprintf('Close Acrobat Reader to proceed!\n')
      eval(sprintf('!acroread %s',filename))
   end

   delete temp.ps
end


